#ifndef __UART_VOFA_H__
#define __UART_VOFA_H__

/*
    vofa_draw_graphical(0);
    if(comGetChar(COM1, &test_data))
        vofa_set_data(test_data);
*/

/* 防止有人没有相关声明类型 */
typedef unsigned char   uint8_t;
typedef uint8_t         u8;

/*
    使用该demo：
        vofa_draw_graphical(0);           ―― 写while中（工作函数）
		vofa_set_data(串口接收的字节数据);  ―― 可以在主函数/串口接收中断回调函数

    打印波形：
    1、在vofa_draw_graphical添加自己需要输出的波形的参数
    1.1、switch中case中的值可以在.h添加宏定义

    接收VOFA命令，改变参数：
    【注意由于处理好的数据都是float，赋值和使用请注意】
    1、在vofa_set_sram_data中添加自己的参数赋值
*/

/***************************************************************************************************************
 *                                               VOFA发送相关（打印波形、……）
 **************************************************************************************************************/
/* 
    当前所使用的数据引擎：
    FireWater:
        本协议是CSV风格的字符串流，直观简洁，编程像printf简单。
        但由于字符串解析消耗更多的运算资源（无论在上位机还是下位机），建议仅在通道数量不多、发送频率不高的时候使用。
        FireWater遇到换行才会打印数据，很多新用户在这里产生疑惑。
    RawData:
        RawData协议适用于不需要解析数据，仅仅查看字节流的需求。
        如果您只把VOFA+当成串口调试助手，不做任何采样数据和图片解析，请务必使用本协议。
    JustFloat:
        本协议是小端浮点数组形式的字节流协议，纯十六进制浮点传输，节省带宽。
        此协议非常适合用在通道数量多、发送频率高的时候。
        字节接收区请勾选十六进制，以十六进制方式打印字符，否则只能打印乱码。
    ...
 */
#define VOFA_DATA_FORMAT "FireWater"

/*
    将单片机串口的函数宏定义于此，用于命令传输
*/
#define VOFA_printf     printf

/*
    选择当前要打印的波形(参数)
    对应vofa_draw_graphical中的switch case
    - 根据自己的需求添加
*/
#define PID_LEFT_MOTOR  0
#define PID_RIGHT_MOTOR 1
#define PID_TURN        2
#define PID_ANGLE		3
// 以此类推

/***************************************************************************************************************
 *                                               VOFA接收相关（接收VOFA的命令、……）
 **************************************************************************************************************/
/*
    上位机VOFA+命令格式采用：
														head_pos↓									end_pos↓
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
|   数据号(用于分清是哪个干什么的数据,1-2byte)   |   帧头('=',1byte)   |   数据位(n byte)   |   包尾('\n',1byte)   |
――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――
    形如：
        "P1=%.2f\n"
        "V2=%.2f\n"
    这里，数据号:"P1/V2"，帧头："...="，帧尾："\n"，数据位长度任意(这里是32bit-float)
*/
#define VOFA_DATAPACK_HEAD      '='     /* VOFA命令帧头 */
#define VOFA_DATAPACK_END       '\n'    /* VOFA命令帧尾 */
#define VOFA_DATAPACK_MAXLEN    200     /* VOFA命令最大长度 */

/*******************************************************************************
 * @brief   通过串口向VOFA+发送数据，输出波形
 * @return {*}
 * @note    none
 * @param {uint8_t} _dataflag   当前打印的数据类别
 *******************************************************************************/
void vofa_draw_graphical(uint8_t _dataflag);

/*******************************************************************************
 * @brief   将此函数添加串口处理字节流的程序中(如串口中断接收中)
 *          将处理接收到的VOFA+的命令解析，并执行对应操作
 * @return {*}
 * @note    目前仅实现了VOFA发送数据的解析
 *******************************************************************************/
void vofa_set_data(uint8_t _rx_byte);

#endif
